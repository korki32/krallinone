<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valorant Agent Wheel — Responsive + Winner Anim + Stats</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Canvas és UI stílusok */
        #wheel {
            transition: transform 0.2s ease-out;
            display: block;
            box-shadow: 0 0 20px rgba(255, 70, 85, 0.5);
        }

        #indicator {
            position: absolute;
            top: -26px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2.5rem;
            color: #FF4655;
            text-shadow: 0 0 10px rgba(255, 70, 85, 0.8);
            z-index: 10;
            pointer-events: none;
        }

        .agent-image.inactive {
            border-color: #FF4655 !important;
            filter: grayscale(80%) brightness(50%);
            opacity: 0.5;
        }

        /* Nyertes kiemelés */
        .winner-highlight {
            animation: winner-glow 1.8s ease-in-out infinite; /* Végtelenítés, hogy látványos maradjon */
            border-radius: 0.5rem;
            transform: translateZ(0) scale(1.03);
            box-shadow: 0 0 30px rgba(255,70,85,0.9), 0 0 6px rgba(255,255,255,0.9) inset;
            z-index: 50;
        }

        @keyframes winner-glow {
            0% { box-shadow: 0 0 6px rgba(255,70,85,0.6); }
            50% { box-shadow: 0 0 30px rgba(255,70,85,0.95); }
            100% { box-shadow: 0 0 6px rgba(255,70,85,0.6); }
        }

        /* Kisebb képernyőn kicsit szebb margin */
        @media (max-width: 640px) {
            #indicator { font-size: 2rem; top: -22px; }
        }

        /* Kisebb segéd stílusok */
        .role-stats { font-size: 0.9rem; color: #cbd5e1; margin-left: 0.6rem; }
    </style>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'valo-red': '#FF4655',
                        'valo-dark': '#0F1923',
                        'valo-gray': '#2A343D',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <!-- Canvas Confetti (browser build) -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
</head>
<body class="bg-valo-dark text-white min-h-screen flex flex-col font-sans" 
      style="background-image: url('images/valorant/valorant_background.jpg'); background-size: cover; background-attachment: fixed;">
    
    <audio id="spin-sound" src="sounds/valorant/spin.mp3" preload="auto"></audio>
    <audio id="stop-sound" src="sounds/valorant/stop.mp3" preload="auto"></audio>

    <header class="bg-black bg-opacity-70 p-5 text-center shadow-lg">
        <h1 class="text-3xl font-bold text-valo-red uppercase tracking-wider">Valorant Agent Wheel</h1>
    </header>

    <main class="flex-grow flex flex-col lg:flex-row items-start justify-center p-4 lg:p-8">
        
        <!-- PÖRGETŐ KERÉK ÉS GOMB SZAKASZ -->
        <section class="w-full lg:w-2/5 p-4 bg-valo-dark bg-opacity-90 rounded-xl shadow-2xl mb-6 lg:mb-0 lg:mr-8 flex flex-col items-center">
            <div id="wheel-container" class="wheel-container relative flex flex-col items-center justify-center w-full max-w-lg">
                <div class="wheel-wrapper relative w-full">
                    <canvas id="wheel" class="rounded-full bg-black border-4 border-valo-red"></canvas>
                    <div id="indicator">▼</div>
                </div>
                <button id="spin" 
                        class="mt-8 px-10 py-4 bg-valo-red hover:bg-red-700 text-white font-extrabold text-xl uppercase rounded-lg shadow-xl transition duration-300 transform hover:scale-105 disabled:opacity-50">
                    PÖRGETÉS
                </button>
                <p class="mt-4 text-xs text-gray-400 max-w-xs">
                    TIPP: Kattints az ügynök képekre lent, hogy ki- vagy bekapcsold őket a keréken, vagy kattints a kategória fejlécére az összes váltásához!
                </p>
                <p id="result-text" class="mt-4 text-2xl font-bold text-green-400" aria-live="assertive"></p>
            </div>
        </section>

        <!-- ÜGYNÖK LISTA SZAKASZ -->
        <section class="w-full lg:w-3/5">
            <div id="agent-list-container" class="space-y-6">
                <!-- Ügynök Kategóriák generálása JS-ből -->
            </div>
        </section>

    </main>

    <footer class="bg-black bg-opacity-70 text-center p-3 text-sm text-gray-400">
        <p>&copy; 2024 Korki32</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- KONSTANSOK ÉS ADATSTRUKTÚRA ---
            const AGENT_STORAGE_KEY = 'valorantAgentWheelState';
            const TWO_PI = 2 * Math.PI;

            const agentData = {
                'Initiator': [
                    { name: 'Sova', image: 'images/valorant/agent_sova.png' },
                    { name: 'Breach', image: 'images/valorant/agent_breach.png' },
                    { name: 'Skye', image: 'images/valorant/agent_skye.png' },
                    { name: 'KAY/O', image: 'images/valorant/agent_kayo.png' },
                    { name: 'Fade', image: 'images/valorant/agent_fade.png' },
                    { name: 'Gekko', image: 'images/valorant/agent_gekko.png' },
                    { name: 'Tejo', image: 'images/valorant/agent_tejo.png' },
                ],
                'Sentinel': [
                    { name: 'Cypher', image: 'images/valorant/agent_cypher.png' },
                    { name: 'Sage', image: 'images/valorant/agent_sage.png' },
                    { name: 'Killjoy', image: 'images/valorant/agent_killjoy.png' },
                    { name: 'Chamber', image: 'images/valorant/agent_chamber.png' },
                    { name: 'Deadlock', image: 'images/valorant/agent_deadlock.png' },
                    { name: 'Vyse', image: 'images/valorant/agent_vyse.png' },
                ],
                'Duelist': [
                    { name: 'Jett', image: 'images/valorant/agent_jett.png' },
                    { name: 'Phoenix', image: 'images/valorant/agent_phoenix.png' },
                    { name: 'Reyna', image: 'images/valorant/agent_reyna.png' },
                    { name: 'Raze', image: 'images/valorant/agent_raze.png' },
                    { name: 'Yoru', image: 'images/valorant/agent_yoru.png' },
                    { name: 'Neon', image: 'images/valorant/agent_neon.png' },
                    { name: 'Iso', image: 'images/valorant/agent_iso.png' },
                    { name: 'Waylay', image: 'images/valorant/agent_waylay.png' },
                ],
                'Controller': [
                    { name: 'Brimstone', image: 'images/valorant/agent_brimstone.png' },
                    { name: 'Viper', image: 'images/valorant/agent_viper.png' },
                    { name: 'Omen', image: 'images/valorant/agent_omen.png' },
                    { name: 'Astra', image: 'images/valorant/agent_astra.png' },
                    { name: 'Harbor', image: 'images/valorant/agent_harbor.png' },
                    { name: 'Clove', image: 'images/valorant/agent_clove.png' }
                ]
            };

            let agents = [];
            for (const role in agentData) {
                agents = agents.concat(agentData[role].map(a => ({ ...a, role, excluded: false })));
            }

            // --- LOCALSTORAGE SEGÉDFÜGGVÉNYEK ---
            function saveAgentState() {
                const stateToSave = agents.map(a => ({ name: a.name, excluded: a.excluded }));
                try { localStorage.setItem(AGENT_STORAGE_KEY, JSON.stringify(stateToSave)); }
                catch (e) { console.error('Hiba a LocalStorage mentésekor:', e); }
            }

            function loadAgentState() {
                try {
                    const storedState = localStorage.getItem(AGENT_STORAGE_KEY);
                    if (storedState) {
                        const parsedState = JSON.parse(storedState);
                        parsedState.forEach(storedAgent => {
                            const existingAgent = agents.find(a => a.name === storedAgent.name);
                            if (existingAgent) existingAgent.excluded = !!storedAgent.excluded;
                        });
                    }
                } catch (e) {
                    console.error('Hiba a LocalStorage betöltésekor. Az alapértelmezett állapotot használjuk.', e);
                }
            }

            // --- DOM és canvas elemek ---
            const canvas = document.getElementById('wheel');
            const canvasContainer = document.getElementById('wheel-container');
            const ctx = canvas.getContext('2d');
            const spinButton = document.getElementById('spin');
            const spinSound = document.getElementById('spin-sound');
            const stopSound = document.getElementById('stop-sound');
            const resultText = document.getElementById('result-text');

            let currentAngle = 0;
            let spinning = false;
            let devicePixelRatioCached = window.devicePixelRatio || 1;
            let continuousSpinRAF = null;
            let lastWinnerName = null; // A nyertes kártya kiemelésének céljából

            // --- RENDER AGENT LIST ÉS STATS ---
            function renderAgentList() {
                const container = document.getElementById('agent-list-container');
                container.innerHTML = '';
                const roleIcons = {
                    'Initiator': 'images/valorant/initiator_icon.png',
                    'Sentinel': 'images/valorant/sentinel_icon.png',
                    'Duelist': 'images/valorant/duelist_icon.png',
                    'Controller': 'images/valorant/controller_icon.png',
                };

                for (const [role, roleAgents] of Object.entries(agentData)) {
                    const total = roleAgents.length;
                    const active = agents.filter(a => a.role === role && !a.excluded).length;

                    const agentClassDiv = document.createElement('div');
                    agentClassDiv.className = 'agent-class p-4 bg-valo-gray bg-opacity-90 rounded-lg shadow-xl';
                    agentClassDiv.innerHTML = `<div class="role-toggle-header flex items-center justify-center mb-4 cursor-pointer transition duration-200 hover:scale-[1.02]" data-role="${role}">
                            <img src="${roleIcons[role]}" alt="${role} Icon" class="w-10 h-10 mr-3 agent-role-icon" onerror="this.src='https://placehold.co/40x40/FF4655/0F1923?text=${role.substring(0, 1)}'">
                            <h2 class="text-2xl font-bold text-valo-red uppercase">${role}</h2>
                            <span class="role-stats">${active}/${total} aktív</span>
                        </div>
                        <div class="agent-container flex flex-wrap justify-center gap-4">
                            ${roleAgents.map(agent => {
                                const fullAgent = agents.find(a => a.name === agent.name);
                                const isInactive = fullAgent.excluded ? 'inactive' : '';
                                return `<div class="agent flex flex-col items-center cursor-pointer transition duration-200 hover:scale-105" data-agent-name="${agent.name}">
                                        <img src="${agent.image}" alt="${agent.name}" class="agent-image w-20 h-20 rounded-xl border-2 border-valo-red object-cover ${isInactive}" onerror="this.onerror=null; this.src='https://placehold.co/80x80/0F1923/FFFFFF?text=${agent.name.substring(0, 3)}'">
                                        <p class="text-sm mt-1">${agent.name}</p>
                                    </div>`;
                            }).join('')}
                        </div>`;
                    container.appendChild(agentClassDiv);
                }

                // Single agent toggle
                container.querySelectorAll('.agent').forEach(agentDiv => {
                    agentDiv.addEventListener('click', function () {
                        if (spinning) return; // Ne engedélyezzük a pörgetés alatt
                        const agentName = this.getAttribute('data-agent-name');
                        const img = this.querySelector('.agent-image');
                        const agentIndex = agents.findIndex(a => a.name === agentName);
                        
                        // Nyertes kiemelés eltávolítása, ha aktív
                        removeWinnerHighlight();

                        if (agentIndex !== -1) {
                            agents[agentIndex].excluded = !agents[agentIndex].excluded;
                            img.classList.toggle('inactive', agents[agentIndex].excluded);
                            drawWheel();
                            saveAgentState();
                            updateRoleStats(agents[agentIndex].role);
                        }
                    });
                });

                // Role toggle
                container.querySelectorAll('.role-toggle-header').forEach(header => {
                    header.addEventListener('click', function() {
                        if (spinning) return; // Ne engedélyezzük a pörgetés alatt
                        const role = this.getAttribute('data-role');
                        const roleAgents = agents.filter(a => a.role === role);
                        const shouldActivateAll = roleAgents.some(a => a.excluded);
                        roleAgents.forEach(agent => { agent.excluded = !shouldActivateAll; });

                        removeWinnerHighlight();

                        // Update DOM images for this role
                        const agentDivs = header.parentElement.querySelectorAll('.agent-container .agent');
                        agentDivs.forEach(div => {
                            const agentName = div.getAttribute('data-agent-name');
                            const agentState = agents.find(a => a.name === agentName);
                            const img = div.querySelector('.agent-image');
                            if (agentState) img.classList.toggle('inactive', agentState.excluded);
                        });

                        drawWheel();
                        saveAgentState();
                        updateRoleStats(role);
                    });
                });
            }

            function updateRoleStats(role) {
                const container = document.getElementById('agent-list-container');
                const roleDiv = Array.from(container.querySelectorAll('.role-toggle-header')).find(h => h.getAttribute('data-role') === role);
                if (!roleDiv) return;
                const total = agentData[role].length;
                const active = agents.filter(a => a.role === role && !a.excluded).length;
                const statsSpan = roleDiv.querySelector('.role-stats');
                if (statsSpan) statsSpan.textContent = `${active}/${total} aktív`;
            }
            
            function removeWinnerHighlight() {
                 if (lastWinnerName) {
                    const lastWinnerCard = document.querySelector(`[data-agent-name="${lastWinnerName}"]`);
                    // Ellenőrizzük, hogy a kártya létezik-e 
                    if (lastWinnerCard) {
                        lastWinnerCard.classList.remove('winner-highlight');
                    }
                    lastWinnerName = null;
                }
            }

            // --- CANVAS MÉRETEZÉSE (RESPONSIVE + DPR) ---
            function resizeCanvas() {
                const containerWidth = Math.min(canvasContainer.clientWidth, 600); // max size
                const dpr = window.devicePixelRatio || 1;
                devicePixelRatioCached = dpr;

                // Set CSS size
                canvas.style.width = containerWidth + 'px';
                canvas.style.height = containerWidth + 'px';

                // Set actual pixel size for crisp rendering
                canvas.width = Math.floor(containerWidth * dpr);
                canvas.height = Math.floor(containerWidth * dpr);

                drawWheel();
            }

            window.addEventListener('resize', function () {
                resizeCanvas();
            });

            // --- KERÉK RAJZOLÁSA ---
            function drawWheel() {
                const activeAgents = agents.filter(agent => !agent.excluded);
                if (activeAgents.length === 0) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    resultText.textContent = 'Nincs aktív ügynök! Engedélyezz legalább egyet.';
                    spinButton.disabled = true;
                    return;
                } else {
                    if (!spinning && !lastWinnerName) resultText.textContent = 'Készen áll a pörgetésre.';
                    spinButton.disabled = false;
                }

                const dpr = devicePixelRatioCached || 1;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const radius = Math.min(canvas.width, canvas.height) / 2;
                ctx.save();
                // A kerék elforgatása a tárolt szöggel
                ctx.translate(radius, radius);
                ctx.rotate(currentAngle);

                const angleStep = TWO_PI / activeAgents.length;
                const colors = ['#FF4655', '#1F2937'];

                activeAgents.forEach((agent, index) => {
                    const angle = index * angleStep;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, radius, angle, angle + angleStep);
                    ctx.lineTo(0, 0);

                    ctx.fillStyle = colors[index % colors.length];
                    ctx.fill();

                    ctx.strokeStyle = '#0F1923';
                    ctx.lineWidth = 4 * dpr;
                    ctx.stroke();

                    // Szöveg
                    ctx.save();
                    ctx.rotate(angle + angleStep / 2);
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = index % 2 === 0 ? '#FFFFFF' : '#FF4655';
                    ctx.font = `bold ${Math.floor(16 * dpr)}px Inter, sans-serif`;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 5 * dpr;
                    ctx.shadowOffsetX = 2 * dpr;
                    ctx.shadowOffsetY = 2 * dpr;

                    // A szöveg a szelet szélére kerül
                    ctx.fillText(agent.name.toUpperCase(), radius * 0.9, 0);
                    ctx.restore();
                });

                // Középső hub
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.beginPath();
                ctx.arc(0, 0, radius * 0.15, 0, TWO_PI);
                ctx.fillStyle = '#0F1923';
                ctx.fill();
                ctx.strokeStyle = '#FF4655';
                ctx.lineWidth = 5 * dpr;
                ctx.stroke();

                ctx.restore();
            }

            // --- PÖRGETÉS ANIMÁCIÓ ---
            function spinWheel(spinAngle, spinDuration) {
                const startTime = Date.now();
                const initialAngle = currentAngle;
                const finalAngle = initialAngle + spinAngle; 

                const easing = (progress) => {
                    // Cubic-Out lassítás a simább megállásért
                    return progress === 1 ? 1 : 1 - Math.pow(1 - progress, 3);
                };

                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / spinDuration, 1);
                    const easedProgress = easing(progress);

                    currentAngle = initialAngle + spinAngle * easedProgress;
                    drawWheel();

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        spinning = false;
                        try { stopSound.play(); } catch (e) { /* hang nélküli fallback */ }
                        determineWinner(finalAngle);
                        startContinuousSpin(); // ÚJRAINDÍTJA a lassú pörgést a győzelem után!
                    }
                }

                animate();
            }

            // --- FOLYAMATOS LASSÚ FORGÁS (KEZDETI VÁRAKOZÓ ÁLLAPOT) ---
            function startContinuousSpin() {
                if (continuousSpinRAF) cancelAnimationFrame(continuousSpinRAF);

                const spinSpeed = 0.002; // Nagyon lassú, folyamatos forgás

                function loop() {
                    // JAVÍTVA: Csak a fő pörgetést ellenőrizzük. A nyertes után is pörög.
                    if (!spinning) { 
                        currentAngle += spinSpeed;
                        drawWheel();
                    }
                    continuousSpinRAF = requestAnimationFrame(loop);
                }

                continuousSpinRAF = requestAnimationFrame(loop);
            }

            // --- NYERTES MEGHATÁROZÁSA ÉS ANIMÁCIÓ ---
            function determineWinner(finalAngle) {
                const activeAgents = agents.filter(agent => !agent.excluded);
                if (activeAgents.length === 0) return;

                // ANGULARIS ELTOLÁS KORREKCIÓJA: Az indikátor 12 óránál van (PI/2 rad CCW eltolás a rajzolás kezdőpontjához képest).
                const indicatorOffset = Math.PI / 2; 

                // 1. Eltoljuk a végső szöget, mintha a jelző 3 óránál lenne.
                let normalizedAngle = (finalAngle + indicatorOffset) % TWO_PI;
                if (normalizedAngle < 0) normalizedAngle += TWO_PI;

                // 2. Invertáljuk az irányt (2*PI - szög) a CCW rajzolású szegmens indexének lekéréséhez.
                let angleInSegmentSpace = (TWO_PI - normalizedAngle) % TWO_PI;

                const angleStep = TWO_PI / activeAgents.length;
                let winningIndex = Math.floor(angleInSegmentSpace / angleStep);
                
                // Index korrekció
                if (winningIndex >= activeAgents.length) winningIndex = activeAgents.length - 1;

                const winner = activeAgents[winningIndex];
                resultText.textContent = `A nyertes ügynök: ${winner.name}! (${winner.role})`;

                // DOM kártya kiemelése
                removeWinnerHighlight();
                const winnerCard = document.querySelector(`[data-agent-name="${winner.name}"]`);
                if (winnerCard) {
                    lastWinnerName = winner.name;
                    try { winnerCard.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch (e) {}
                    winnerCard.classList.add('winner-highlight');
                }

                // Confetti effekt
                try {
                    confetti({ particleCount: 140, spread: 80, origin: { y: 0.45 } });
                    confetti({ particleCount: 80, spread: 120, origin: { y: 0.6 } });
                } catch (e) {
                    console.warn('Confetti hiba:', e);
                }
            }

            // --- SPIN GOMB ESEMÉNY ---
            spinButton.addEventListener('click', function () {
                const activeAgents = agents.filter(agent => !agent.excluded);
                if (spinning || activeAgents.length === 0) return;

                // Stop continuous spin before starting the main spin
                if (continuousSpinRAF) {
                    cancelAnimationFrame(continuousSpinRAF);
                    continuousSpinRAF = null;
                }
                removeWinnerHighlight(); 

                spinning = true;
                resultText.textContent = 'Pörgetés...';
                try { spinSound.play(); } catch (e) {}

                // Minimum 6 teljes fordulat plusz random fordulat.
                const totalRevolutions = 6 + Math.random() * 4; 
                const spinAngle = totalRevolutions * TWO_PI;
                const spinDuration = 6000 + Math.random() * 2000;

                spinWheel(spinAngle, spinDuration);
            });

            // --- INITIALIZÁLÁS ---
            loadAgentState();
            renderAgentList();
            resizeCanvas();
            startContinuousSpin(); // Kezdeti lassú pörgés a felhasználói interakcióig
        });
    </script>
</body>
</html>
