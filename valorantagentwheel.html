<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Valorant Agent Wheel</title>
    <!-- Tailwind CSS betöltése reszponzív stílusokhoz -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Egyedi Canvas stílus, hogy kör alakú legyen és a tartóelemen belül maradjon */
        #wheel {
            transition: transform 0.2s ease-out;
            /* A Canvas elemet blokk szintűvé tesszük */
            display: block;
            /* Enyhe doboz árnyék a keréknek a mélységért */
            box-shadow: 0 0 20px rgba(255, 70, 85, 0.5);
        }

        /* A jelző pozícionálása a kerék tetejére */
        #indicator {
            position: absolute;
            top: -20px; 
            left: 50%;
            transform: translateX(-50%);
            font-size: 2.5rem; /* Nagyobb méret */
            color: #FF4655; /* Valorant piros szín */
            text-shadow: 0 0 10px rgba(255, 70, 85, 0.8);
            z-index: 10;
            pointer-events: none; 
        }

        /* Stílus az inaktív ügynököknek */
        .agent-image.inactive {
            border-color: #FF4655 !important; /* Piros keret */
            filter: grayscale(80%) brightness(50%);
            opacity: 0.5;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'valo-red': '#FF4655',
                        'valo-dark': '#0F1923',
                        'valo-gray': '#2A343D',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-valo-dark text-white min-h-screen flex flex-col font-sans" 
      style="background-image: url('images/valorant/valorant_background.jpg'); background-size: cover; background-attachment: fixed;">
    
    <!-- AUDIO ELEMEK (a böngésző biztonsági korlátai miatt az audio fájlokat a felhasználóknak maguknak kell elérhetővé tenniük) -->
    <audio id="spin-sound" src="sounds/valorant/spin.mp3" preload="auto"></audio>
    <audio id="stop-sound" src="sounds/valorant/stop.mp3" preload="auto"></audio>

    <header class="bg-black bg-opacity-70 p-5 text-center shadow-lg">
        <h1 class="text-3xl font-bold text-valo-red uppercase tracking-wider">Valorant Agent Wheel</h1>
    </header>

    <main class="flex-grow flex flex-col lg:flex-row items-start justify-center p-4 lg:p-8">
        
        <!-- PÖRGETŐ KERÉK ÉS GOMB SZAKASZ -->
        <section class="w-full lg:w-2/5 p-4 bg-valo-dark bg-opacity-90 rounded-xl shadow-2xl mb-6 lg:mb-0 lg:mr-8 flex flex-col items-center">
            <div class="wheel-container relative flex flex-col items-center justify-center">
                <div class="wheel-wrapper relative w-full max-w-lg aspect-square">
                    <canvas id="wheel" width="500" height="500" class="rounded-full bg-black border-4 border-valo-red"></canvas>
                    <div id="indicator">▼</div>
                </div>
                <button id="spin" 
                        class="mt-8 px-10 py-4 bg-valo-red hover:bg-red-700 text-white font-extrabold text-xl uppercase rounded-lg shadow-xl transition duration-300 transform hover:scale-105 disabled:opacity-50">
                    PÖRGETÉS
                </button>
                <p class="mt-4 text-xs text-gray-400 max-w-xs">
                    TIPP: Kattints az ügynök képekre lent, hogy ki- vagy bekapcsold őket a keréken, vagy kattints a kategória fejlécére az összes váltásához!
                </p>
                <p id="result-text" class="mt-4 text-2xl font-bold text-green-400"></p>
            </div>
        </section>

        <!-- ÜGYNÖK LISTA SZAKASZ -->
        <section class="w-full lg:w-3/5">
            <div id="agent-list-container" class="space-y-6">
                <!-- Ügynök Kategóriák generálása JS-ből -->
            </div>
        </section>

    </main>

    <footer class="bg-black bg-opacity-70 text-center p-3 text-sm text-gray-400">
        <p>&copy; 2024 Korki32. Átalakítva a Web Guru által, Tailwind CSS és egyfájlos architektúra használatával.</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- KONSTANSOK ÉS ADATSTRUKTÚRA ---
            const AGENT_STORAGE_KEY = 'valorantAgentWheelState';

            // A VALORANT ÜGYNÖKÖK DEFINÍCIÓJA KATEGÓRIÁKRA OSZTVA
            const agentData = {
                'Initiator': [
                    { name: 'Sova', image: 'images/valorant/agent_sova.png' },
                    { name: 'Breach', image: 'images/valorant/agent_breach.png' },
                    { name: 'Skye', image: 'images/valorant/agent_skye.png' },
                    { name: 'KAY/O', image: 'images/valorant/agent_kayo.png' },
                    { name: 'Fade', image: 'images/valorant/agent_fade.png' },
                    { name: 'Gekko', image: 'images/valorant/agent_gekko.png' },
                    { name: 'Tejo', image: 'images/valorant/agent_tejo.png' },
                ],
                'Sentinel': [
                    { name: 'Cypher', image: 'images/valorant/agent_cypher.png' },
                    { name: 'Sage', image: 'images/valorant/agent_sage.png' },
                    { name: 'Killjoy', image: 'images/valorant/agent_killjoy.png' },
                    { name: 'Chamber', image: 'images/valorant/agent_chamber.png' },
                    { name: 'Deadlock', image: 'images/valorant/agent_deadlock.png' },
                    { name: 'Vyse', image: 'images/valorant/agent_vyse.png' },
                ],
                'Duelist': [
                    { name: 'Jett', image: 'images/valorant/agent_jett.png' },
                    { name: 'Phoenix', image: 'images/valorant/agent_phoenix.png' },
                    { name: 'Reyna', image: 'images/valorant/agent_reyna.png' },
                    { name: 'Raze', image: 'images/valorant/agent_raze.png' },
                    { name: 'Yoru', image: 'images/valorant/agent_yoru.png' },
                    { name: 'Neon', image: 'images/valorant/agent_neon.png' },
                    { name: 'Iso', image: 'images/valorant/agent_iso.png' },
                    { name: 'Waylay', image: 'images/valorant/agent_waylay.png' },
                ],
                'Controller': [
                    { name: 'Brimstone', image: 'images/valorant/agent_brimstone.png' },
                    { name: 'Viper', image: 'images/valorant/agent_viper.png' },
                    { name: 'Omen', image: 'images/valorant/agent_omen.png' },
                    { name: 'Astra', image: 'images/valorant/agent_astra.png' },
                    { name: 'Harbor', image: 'images/valorant/agent_harbor.png' },
                    { name: 'Clove', image: 'images/valorant/agent_clove.png' }
                ]
            };
            
            // Az összes ügynök listája a Canvas rajzolásához (kategóriák nélkül, alapértelmezett állapot)
            let agents = [];
            for (const role in agentData) {
                agents = agents.concat(agentData[role].map(a => ({ ...a, role, excluded: false })));
            }

            // --- SEGÉDFÜGGVÉNYEK LOCAL STORAGE-HEZ ---

            /**
             * Elmenti az ügynökök aktuális "excluded" állapotát a Local Storage-ba.
             */
            function saveAgentState() {
                const stateToSave = agents.map(a => ({ name: a.name, excluded: a.excluded }));
                try {
                    localStorage.setItem(AGENT_STORAGE_KEY, JSON.stringify(stateToSave));
                } catch (e) {
                    console.error("Hiba a LocalStorage mentésekor:", e);
                }
            }

            /**
             * Betölti az ügynökök állapotát a Local Storage-ból, és összeveti az alap adatokkal.
             */
            function loadAgentState() {
                try {
                    const storedState = localStorage.getItem(AGENT_STORAGE_KEY);
                    if (storedState) {
                        const parsedState = JSON.parse(storedState);
                        
                        // Összevonjuk a betöltött állapotot a jelenlegi ügynök adatokkal
                        parsedState.forEach(storedAgent => {
                            const existingAgent = agents.find(a => a.name === storedAgent.name);
                            if (existingAgent) {
                                // Csak a logikailag helyes állapotot vesszük át (boolean)
                                existingAgent.excluded = !!storedAgent.excluded;
                            }
                        });
                    }
                } catch (e) {
                    // Ha a LocalStorage tartalom sérült (pl. nem érvényes JSON)
                    console.error("Hiba a LocalStorage betöltésekor. Az alapértelmezett állapotot használjuk.", e);
                }
            }

            // --- DOM ELEMEK ÉS ÁLLAPOT VÁLTOZÓK ---
            const canvas = document.getElementById('wheel');
            const ctx = canvas.getContext('2d');
            const spinButton = document.getElementById('spin');
            const spinSound = document.getElementById('spin-sound');
            const stopSound = document.getElementById('stop-sound');
            const resultText = document.getElementById('result-text');
            
            const radius = canvas.width / 2;
            let currentAngle = 0;
            let spinning = false;


            /**
             * Agent kategóriák dinamikus renderelése a HTML-be
             */
            function renderAgentList() {
                const container = document.getElementById('agent-list-container');
                container.innerHTML = '';
                const roleIcons = {
                    'Initiator': 'images/valorant/initiator_icon.png',
                    'Sentinel': 'images/valorant/sentinel_icon.png',
                    'Duelist': 'images/valorant/duelist_icon.png',
                    'Controller': 'images/valorant/controller_icon.png',
                };

                for (const [role, roleAgents] of Object.entries(agentData)) {
                    const agentClassDiv = document.createElement('div');
                    agentClassDiv.className = 'agent-class p-4 bg-valo-gray bg-opacity-90 rounded-lg shadow-xl';
                    
                    agentClassDiv.innerHTML = `
                        <!-- Kategória Fejléc: Kattintható az összes ügynök ki/bekapcsolásához -->
                        <div class="role-toggle-header flex items-center justify-center mb-4 cursor-pointer transition duration-200 hover:scale-[1.02]" data-role="${role}">
                            <img src="${roleIcons[role]}" alt="${role} Icon" class="w-10 h-10 mr-3 agent-role-icon" 
                                onerror="this.src='https://placehold.co/40x40/FF4655/0F1923?text=${role.substring(0, 1)}'"> <!-- Placeholder ikon, ha az URL nem működik -->
                            <h2 class="text-2xl font-bold text-valo-red uppercase">${role}</h2>
                        </div>
                        <div class="agent-container flex flex-wrap justify-center gap-4">
                            ${roleAgents.map(agent => {
                                const fullAgent = agents.find(a => a.name === agent.name);
                                const isInactive = fullAgent.excluded ? 'inactive' : '';
                                return `
                                    <div class="agent flex flex-col items-center cursor-pointer transition duration-200 hover:scale-105" data-agent-name="${agent.name}">
                                        <img src="${agent.image}" alt="${agent.name}" class="agent-image w-20 h-20 rounded-xl border-2 border-valo-red object-cover ${isInactive}" 
                                            onerror="this.onerror=null; this.src='https://placehold.co/80x80/0F1923/FFFFFF?text=${agent.name.substring(0, 3)}'"> <!-- Placeholder kép, ha az URL nem működik -->
                                        <p class="text-sm mt-1">${agent.name}</p>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                    container.appendChild(agentClassDiv);
                }

                // Eseménykezelők hozzáadása az egyes ügynök képekhez (SINGLE AGENT TOGGLE)
                container.querySelectorAll('.agent').forEach(agentDiv => {
                    agentDiv.addEventListener('click', function () {
                        const agentName = this.getAttribute('data-agent-name');
                        const img = this.querySelector('.agent-image');
                        const agentIndex = agents.findIndex(a => a.name === agentName);

                        if (agentIndex !== -1) {
                            agents[agentIndex].excluded = !agents[agentIndex].excluded;
                            img.classList.toggle('inactive', agents[agentIndex].excluded);
                            drawWheel(); // Újra rajzoljuk a kereket az aktuális agent listával
                            saveAgentState(); // Mentjük az új állapotot
                        }
                    });
                });

                // Eseménykezelő a kategória fejlécekhez (ROLE TOGGLE)
                container.querySelectorAll('.role-toggle-header').forEach(header => {
                    header.addEventListener('click', function() {
                        const role = this.getAttribute('data-role');
                        const roleAgents = agents.filter(a => a.role === role);
                        
                        // Logika: ha BÁRMELYIK ügynök inaktív, mindent aktiválunk. Különben (ha mindenki aktív), mindent inaktiválunk.
                        const shouldActivateAll = roleAgents.some(a => a.excluded);

                        // Végigfutás az ügynökökön és az állapot beállítása
                        roleAgents.forEach(agent => {
                            agent.excluded = !shouldActivateAll;
                        });

                        // Frissítjük a DOM-ot az adott kategórián belül
                        const agentDivs = container.querySelectorAll(`[data-role="${role}"] ~ .agent-container .agent`);
                        agentDivs.forEach(div => {
                            const agentName = div.getAttribute('data-agent-name');
                            const agentState = agents.find(a => a.name === agentName);
                            const img = div.querySelector('.agent-image');

                            if (agentState) {
                                img.classList.toggle('inactive', agentState.excluded);
                            }
                        });

                        drawWheel();
                        saveAgentState();
                    });
                });
            }

            /**
             * A kerék rajzolása a Canvas-ra (FELJAVÍTOTT VIZUÁLIS MEGJELENÉS)
             */
            function drawWheel() {
                const activeAgents = agents.filter(agent => !agent.excluded);
                if (activeAgents.length === 0) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    resultText.textContent = 'Nincs aktív ügynök! Engedélyezz legalább egyet.';
                    spinButton.disabled = true;
                    return;
                } else {
                    resultText.textContent = '';
                    spinButton.disabled = false;
                }

                const angleStep = (2 * Math.PI) / activeAgents.length;
                // Valorant-témájú színek: Piros és Sötétszürke
                const colors = ['#FF4655', '#1F2937']; 

                ctx.save();
                ctx.translate(radius, radius);
                ctx.rotate(currentAngle);
                
                activeAgents.forEach((agent, index) => {
                    const angle = index * angleStep;
                    
                    // Szelet rajzolása
                    ctx.beginPath();
                    ctx.moveTo(0, 0); 
                    ctx.arc(0, 0, radius, angle, angle + angleStep);
                    ctx.lineTo(0, 0);
                    
                    // Szín beállítása
                    ctx.fillStyle = colors[index % colors.length]; 
                    ctx.fill();

                    // Szelet határa
                    ctx.strokeStyle = '#0F1923'; // Valorant sötét
                    ctx.lineWidth = 4; // Vastagabb vonal
                    ctx.stroke();

                    // Szöveg rajzolása (ügynök neve)
                    ctx.save();
                    ctx.rotate(angle + angleStep / 2); // Forgatás a szelet közepére
                    
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'middle'; // Középre igazítás
                    // Piros szeleten fehér szöveg, sötétszürke szeleten piros szöveg a kontraszt miatt
                    ctx.fillStyle = index % 2 === 0 ? '#FFFFFF' : '#FF4655'; 
                    ctx.font = 'bold 20px Inter, sans-serif'; // Nagyobb, vastagabb betű
                    
                    // Elegánsabb árnyék a szöveghez
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 5;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;

                    ctx.fillText(agent.name.toUpperCase(), radius * 0.9, 0); 
                    
                    ctx.restore(); // Visszaállítjuk a szövegstílust
                });

                // --- Középső kör (hub) hozzáadása a kerék közepére ---
                // Árnyék eltávolítása a kör rajzolásához, hogy csak a szövegen legyen árnyék
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                ctx.beginPath();
                ctx.arc(0, 0, radius * 0.15, 0, 2 * Math.PI);
                ctx.fillStyle = '#0F1923'; // Sötét központ
                ctx.fill();
                ctx.strokeStyle = '#FF4655';
                ctx.lineWidth = 5;
                ctx.stroke();

                ctx.restore(); // Visszaállítjuk a Canvas állapotát
            }

            /**
             * A kerék animálása pörgetés közben
             */
            function spinWheel(spinAngle, spinDuration) {
                const startTime = Date.now();
                const initialAngle = currentAngle;

                // Be- és kifutási függvény a pörgetéshez (ease-out)
                const easing = (progress) => {
                    return progress === 1 ? 1 : 1 - Math.pow(2, -10 * progress); 
                };

                // A pörgetés végső szögének kiszámítása
                const finalAngle = initialAngle + spinAngle;
                
                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / spinDuration, 1);
                    const easedProgress = easing(progress);

                    currentAngle = initialAngle + spinAngle * easedProgress;
                    drawWheel();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        spinning = false; 
                        stopSound.play().catch(e => console.error("Leállítási hang hiba:", e));

                        // Eredmény meghatározása
                        determineWinner(finalAngle);
                        startContinuousSpin(); // Újraindítjuk a lassú pörgést
                    }
                }

                animate();
            }

            /**
             * Folyamatos, lassú forgás a kezdeti állapothoz
             */
            function startContinuousSpin() {
                if (spinning) return; // Ne indítsuk újra, ha már pörög

                const spinSpeed = 0.005; // Nagyon lassú forgási sebesség

                function animateContinuous() {
                    if (!spinning) {
                        currentAngle += spinSpeed;
                        drawWheel();
                        requestAnimationFrame(animateContinuous);
                    }
                }

                // Elindítjuk az animációs loopot, ha még nem pörög
                if (!spinning) {
                    requestAnimationFrame(animateContinuous);
                }
            }

            /**
             * A nyertes ügynök meghatározása a pörgetés végén
             */
            function determineWinner(finalAngle) {
                const activeAgents = agents.filter(agent => !agent.excluded);
                if (activeAgents.length === 0) return;

                // Az elforgatott szög normalizálása 0 és 2π közé
                let normalizedAngle = finalAngle % (2 * Math.PI);
                if (normalizedAngle < 0) {
                    normalizedAngle += 2 * Math.PI;
                }
                
                // A kerék forgása az óramutató járásával ellentétes
                // Vissza kell invertálni, hogy a nyertes szektort kapjuk meg a 0-hoz képest.
                // A jelző a kerék tetején (0 radian)
                let indicatorAngle = (2 * Math.PI - normalizedAngle) % (2 * Math.PI);

                const angleStep = (2 * Math.PI) / activeAgents.length;
                let winningIndex = Math.floor(indicatorAngle / angleStep);

                // Biztosítjuk, hogy az index a tömb határain belül legyen
                if (winningIndex >= activeAgents.length) {
                    winningIndex = activeAgents.length - 1;
                }
                
                const winner = activeAgents[winningIndex];
                resultText.textContent = `A nyertes ügynök: ${winner.name}! (${winner.role})`;
            }

            // Eseménykezelő a SPIN gombhoz
            spinButton.addEventListener('click', function () {
                const activeAgents = agents.filter(agent => !agent.excluded);
                if (spinning || activeAgents.length === 0) return; 

                spinning = true; 
                resultText.textContent = 'Pörgetés...';
                spinSound.play().catch(e => console.error("Pörgetési hang hiba:", e));
                
                // Gyors pörgetés (6-10 teljes fordulat)
                const totalRevolutions = 6 + Math.random() * 4; 
                const spinAngle = totalRevolutions * 2 * Math.PI;
                const spinDuration = 6000 + Math.random() * 2000; // 6-8 másodperc

                spinWheel(spinAngle, spinDuration);
            });

            // --- INITIALIZÁLÁS ---
            loadAgentState(); // 1. Betöltjük az állapotot
            renderAgentList(); // 2. Megjelenítjük a listát (a betöltött állapot alapján)
            drawWheel(); // 3. Rajzoljuk a kereket
            startContinuousSpin(); // 4. Elindítjuk a lassú pörgést
        });
    </script>
</body>
</html>
