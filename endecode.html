<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Endecode - √úzenet K√≥dol√≥ √©s Ford√≠t√≥</title>

  <!-- Inter font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    :root { --soft-bg: #f1f5f9; --soft-text: #0f172a; }
    body { font-family: 'Inter', sans-serif; margin: 0; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }

    /* Canvas h√°tt√©r */
    #futuristic-canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      display:block;
      background: linear-gradient(180deg,#071025 0%, #071025 100%);
    }

    /* Gombok */
    .switch-mode-btn {
      background-color: #22c55e; /* Z√∂ldes sz√≠n */
      color: white;
      padding: 10px 16px;
      border: none;
      border-radius: 9999px;
      cursor: pointer;
      transition: transform .18s ease, background-color .18s ease;
      box-shadow: 0 6px 18px rgba(34,197,94,0.12);
    }
    .switch-mode-btn:hover { transform: translateY(-2px); background-color:#16a34a; }

    /* Kisebb responsive jav√≠t√°sok */
    @media (max-width:640px) {
      #theme-toggle { right: .5rem; top: .5rem; }
    }

    /* F≈ë doboz st√≠lusa */
    .glass-panel {
      background-color: rgba(24, 30, 41, 0.85);
      backdrop-filter: blur(12px);
    }
    
    /* Leny√≠l√≥ men√º jav√≠t√°s */
    select, select option {
        background-color: #1e293b;
        color: white;
    }
    
    /* M√°sol√°s gomb st√≠lus */
    #copy-btn {
      transition: opacity .2s ease, background-color .2s ease;
    }
    #copy-btn[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
      background-color: #4b5563; /* S√∂t√©tsz√ºrke az inakt√≠v √°llapothoz */
    }
  </style>
</head>
<body class="min-h-screen transition-colors duration-300">

  <!-- Canvas a h√°tt√©rhez -->
  <canvas id="futuristic-canvas"></canvas>

  <!-- F≈ë tartalom -->
  <main class="relative z-10 flex items-start justify-center p-6 pt-16">
    <div class="glass-panel rounded-3xl shadow-2xl w-full max-w-2xl p-8 relative overflow-hidden">
      <!-- bels≈ë jobb fels≈ë: switch mode -->
      <div class="absolute top-4 right-4">
        <button id="switch-mode-btn" class="switch-mode-btn">Dek√≥dol√°sra v√°lt√°s</button>
      </div>

      <h1 class="text-4xl font-extrabold text-white text-center mb-3">Endecode</h1>
      <p class="text-center text-gray-300 mb-8">√úzenet k√≥dol√≥ √©s ford√≠t√≥ k√ºl√∂nb√∂z≈ë algoritmusokkal.</p>

      <!-- Form -->
      <div id="dynamic-section" class="space-y-6">
        <div id="input-group">
          <label for="message-input" class="block text-lg font-semibold text-gray-300 mb-2">√úzenet:</label>
          <textarea id="message-input" class="w-full h-32 p-4 border border-gray-600 rounded-lg bg-transparent text-white resize-none shadow-sm transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="√çrd be az √ºzenetet..."></textarea>
          <div class="flex justify-between text-gray-400 text-sm mt-2">
            <span id="char-count">0 karakter</span>
            <span id="word-count">0 sz√≥</span>
          </div>
        </div>

        <div id="vigenere-key-group" class="hidden">
          <label for="vigenere-key" class="block text-lg font-semibold text-gray-300 mb-2">Vigen√®re kulcs:</label>
          <input type="text" id="vigenere-key" class="w-full p-3 border border-gray-600 rounded-lg bg-transparent text-white shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="√çrd be a kulcsot...">
        </div>

        <div id="caesar-shift-group" class="hidden">
          <label for="caesar-shift" class="block text-lg font-semibold text-gray-300 mb-2">Caesar eltol√°s: <span id="caesar-shift-value">3</span></label>
          <input type="range" id="caesar-shift" min="1" max="25" value="3" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
        </div>

        <div>
          <label for="cipher-select" class="block text-lg font-semibold text-gray-300 mb-2">K√≥dol√°s/Dek√≥dol√°s t√≠pusa:</label>
          <select id="cipher-select" class="w-full p-3 border border-gray-600 rounded-lg bg-transparent text-white shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
            <option value="rot13">ROT13</option>
            <option value="rot47">ROT47</option>
            <option value="atbash">Atbash</option>
            <option value="binary">Bin√°ris</option>
            <option value="base64">Base64</option>
            <option value="base85">Base85</option>
            <option value="base32">Base32</option>
            <option value="base58">Base58</option>
            <option value="hex">Hexadecim√°lis</option>
            <option value="url">URL K√≥dol√°s/Dek√≥dol√°s</option>
            <option value="caesar">Caesar K√≥d</option>
            <option value="vigenere">Vigen√®re-k√≥d</option>
            <option value="morse">Morse K√≥d</option>
            <option value="html-entities">HTML Entit√°sok</option>
            <option value="utf8">UTF-8</option>
            <option value="leet">Leet Speak</option>
            <option value="emoji">KR Emoji 1.2</option>
          </select>
        </div>

        <div class="pt-4">
          <label class="block text-lg font-semibold text-gray-300 mb-2">Eredm√©ny:</label>
          <div id="result" class="relative min-h-[128px] w-full p-4 border border-gray-600 rounded-lg bg-transparent text-white shadow-sm break-words whitespace-pre-wrap overflow-x-auto">
            <button id="copy-btn" class="bg-gray-600 text-white p-3 rounded-lg shadow-md hover:bg-gray-700 transition-colors hidden" title="M√°sol√°s">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v2M8 5h6" />
              </svg>
            </button>
          </div>
        </div>
      </div>

      <footer class="text-center text-gray-400 mt-8 text-sm">
        <p>&copy; 2024 Korki32</p>
      </footer>
    </div>
  </main>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      /* ---------- elemek ---------- */
      const canvas = document.getElementById('futuristic-canvas');
      const ctx = canvas.getContext?.('2d');
      const themeToggle = document.getElementById('theme-toggle');
      const messageInput = document.getElementById('message-input');
      const cipherSelect = document.getElementById('cipher-select');
      const resultDiv = document.getElementById('result');
      const switchModeBtn = document.getElementById('switch-mode-btn');
      const vigenereKeyGroup = document.getElementById('vigenere-key-group');
      const vigenereKeyInput = document.getElementById('vigenere-key');
      const caesarShiftGroup = document.getElementById('caesar-shift-group');
      const caesarShiftInput = document.getElementById('caesar-shift');
      const caesarShiftValueSpan = document.getElementById('caesar-shift-value');
      const copyBtn = document.getElementById('copy-btn');
      const charCountSpan = document.getElementById('char-count');
      const wordCountSpan = document.getElementById('word-count');

      /* ---------- √°llapot ---------- */
      let currentMode = 'encode'; // vagy 'decode'

      /* ---------- h√°tt√©r anim√°ci√≥ (canvas) ---------- */
      if (canvas && ctx) {
        const matrixCharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890@#$%^&*()_+{}|:<>?-=[]\\;\'",./`~';
        let streams = [];
        const fontSize = 16;
        const columns = Math.floor(canvas.width / fontSize);

        function initializeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const newColumns = Math.floor(canvas.width / fontSize);
            streams = [];
            for (let i = 0; i < newColumns; i++) {
                streams.push({
                    x: i * fontSize,
                    y: Math.random() * canvas.height,
                    speed: Math.random() * 5 + 1
                });
            }
        }

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0F0';
            ctx.font = `${fontSize}px 'Roboto Mono'`;

            streams.forEach(stream => {
                const char = matrixCharacters.charAt(Math.floor(Math.random() * matrixCharacters.length));
                ctx.fillText(char, stream.x, stream.y);

                if (stream.y > canvas.height + 50) {
                    stream.y = 0;
                } else {
                    stream.y += stream.speed;
                }
            });
        }

        initializeCanvas();
        setInterval(draw, 30);
        window.addEventListener('resize', initializeCanvas);
      }

      /* ---------- seg√©df√ºggv√©nyek √©s k√≥dol√≥k ---------- */

      // Morse
      const morseCodeMap = {
        'A':'.-','B':'-...','C':'-.-.','D':'-..','E':'.','F':'..-.','G':'--.',
        'H':'....','I':'..','J':'.---','K':'-.-','L':'.-..','M':'--','N':'-.',
        'O':'---','P':'.--.','Q':'--.-','R':'.-.','S':'...','T':'-','U':'..-',
        'V':'...-','W':'.--','X':'-..-','Y':'-.--','Z':'--..','0':'-----','1':'.----',
        '2':'..---','3':'...--','4':'....-','5':'.....','6':'-....','7':'--...','8':'---..','9':'----.',' ':'/'
      };
      const reverseMorseCodeMap = Object.fromEntries(Object.entries(morseCodeMap).map(([k,v])=>[v,k]));

      // Leet
      const leetSpeakMap = {'A':'4','B':'8','E':'3','G':'9','I':'1','O':'0','S':'5','T':'7'};
      const reverseLeetSpeakMap = Object.fromEntries(Object.entries(leetSpeakMap).map(([k,v])=>[v,k]));

      // Emoji map (egyszer≈±)
      const emojiMap = {'A':'üçè','B':'üçå','C':'ü•í','D':'üç©','E':'üçÜ','F':'üçü','G':'üçá','H':'üçØ','I':'üç¶','J':'üåµ','K':'üç™','L':'üçã','M':'üçà','N':'üçâ','O':'üçä','P':'üçç','Q':'üçë','R':'üçí','S':'üçì','T':'üçÖ','U':'ü•®','V':'üßá','W':'üç≠','X':'üçÑ','Y':'üßä','Z':'üçé','√Å':'ü•ë','√â':'ü••','√ç':'ü•ù','√ì':'üßÄ','√ñ':'üçî','≈ê':'ü•ß','√ö':'üç•','√ú':'üçï','≈∞':'üå≠','1':'ü•ú','2':'üç£','3':'ü•ê','4':'üçñ','5':'üçó','6':'ü•©','7':'ü•ö','8':'ü•†','9':'üçø','.':'üßÅ','!':'üç∞','?':'üç´','-':'üç¨',' ':'ü•õ'};
      const reverseEmojiMap = Object.fromEntries(Object.entries(emojiMap).map(([k,v])=>[v,k]));

      // Base32 (simple)
      const alphabet32 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
      const encodeBase32 = (str) => {
        let binary = '';
        for (let i=0;i<str.length;i++) binary += str.charCodeAt(i).toString(2).padStart(8,'0');
        let out='';
        for (let i=0;i<binary.length;i+=5) {
          const chunk = binary.substring(i,i+5).padEnd(5,'0');
          out += alphabet32[parseInt(chunk,2)];
        }
        while (out.length % 8 !== 0) out += '=';
        return out;
      };
      const decodeBase32 = (s) => {
        s = s.replace(/=+$/,'');
        let binary = '';
        for (let ch of s) {
          const idx = alphabet32.indexOf(ch.toUpperCase());
          if (idx === -1) throw new Error('Invalid Base32');
          binary += idx.toString(2).padStart(5,'0');
        }
        let out=''; for (let i=0;i<binary.length;i+=8) { const byte = binary.substring(i,i+8); if (byte.length<8) break; out += String.fromCharCode(parseInt(byte,2)); } 
        return out;
      };

      // Base58 (works for text -> simplistic)
      const alphabet58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      const encodeBase58 = (str) => {
        // convert to BigInt
        let hex = '';
        for (let i=0;i<str.length;i++) hex += str.charCodeAt(i).toString(16).padStart(2,'0');
        let num = BigInt('0x' + (hex || '0'));
        if (num === 0n) return '1';
        let out = '';
        while (num > 0n) { const r = num % 58n; out = alphabet58[Number(r)] + out; num = num / 58n; }
        return out;
      };
      const decodeBase58 = (s) => {
        let num = 0n;
        for (let ch of s) {
          const idx = alphabet58.indexOf(ch);
          if (idx === -1) throw new Error('Invalid Base58');
          num = num * 58n + BigInt(idx);
        }
        let hex = num.toString(16);
        if (hex.length % 2) hex = '0' + hex;
        let out = '';
        for (let i=0;i<hex.length;i+=2) out += String.fromCharCode(parseInt(hex.substring(i,i+2),16));
        return out;
      };

      // Base85 (Ascii85) - create alphabet programmatically (chars 33..117, length 85)
      const ascii85 = {
        alphabet: Array.from({length:85}, (_,i)=>String.fromCharCode(33 + i)).join(''),
        encode: function(str) {
          // simple Ascii85 encode implementation (not fully padded-edge perfect but functional)
          const bytes = new TextEncoder().encode(str);
          let out = '<~';
          for (let i = 0; i < bytes.length; i += 4) {
            const chunk = bytes.slice(i, i + 4);
            let val = 0;
            for (let b = 0; b < 4; b++) { val = (val << 8) + (chunk[b] || 0); }
            if (chunk.length === 4 && val === 0) { out += 'z'; continue; }
            let chars = [];
            for (let j = 0; j < 5; j++) { chars.unshift(this.alphabet[val % 85]); val = Math.floor(val / 85); }
            out += chars.slice(0, chunk.length + 1).join('');
          }
          out += '~>';
          return out;
        },
        decode: function(str) {
          if (str.startsWith('<~') && str.endsWith('~>')) str = str.slice(2,-2).replace(/\s/g,'');
          else throw new Error('Invalid Ascii85');
          // handle 'z' => 4 zero bytes
          let bytes = [];
          for (let i=0;i<str.length;i++) {
            if (str[i] === 'z') { bytes.push(0,0,0,0); continue; }
            // gather 5 chars (or less at end)
            const chunk = str.slice(i, i+5);
            if (chunk.length < 5) {
              // pad with '!' (value 0) for calculation but will reduce later
              let padded = chunk.padEnd(5, '!');
              let val = 0;
              for (let ch of padded) val = val * 85 + this.alphabet.indexOf(ch);
              // produce 4 bytes then slice
              let temp = [];
              for (let k=3;k>=0;k--) { temp.unshift((val >> (8*k)) & 0xFF); }
              // push only needed bytes
              const needed = chunk.length - 1;
              for (let n = 0; n < needed; n++) bytes.push(temp[n]);
              break;
            } else {
              let val = 0;
              for (let ch of chunk) val = val * 85 + this.alphabet.indexOf(ch);
              for (let k=3;k>=0;k--) bytes.push((val >> (8*k)) & 0xFF);
              i += 4; // will be incremented by loop too (so net +5)
            }
          }
          return new TextDecoder().decode(new Uint8Array(bytes));
        }
      };

      // Vigenere (safe: ha kulcs √ºres -> hibasz√∂veg)
      const vigenereEncode = (text, key) => {
        key = (key || '').toUpperCase().replace(/[^A-Z]/g,'');
        if (!key) throw new Error('√úres Vigen√®re kulcs');
        let res=''; let ki=0;
        for (let ch of text) {
          const isUpper = ch >= 'A' && ch <= 'Z';
          const isLower = ch >= 'a' && ch <= 'z';
          if (isUpper || isLower) {
            const base = isUpper ? 65 : 97;
            const shift = key.charCodeAt(ki % key.length) - 65;
            res += String.fromCharCode(base + (ch.charCodeAt(0) - base + shift + 26) % 26);
            ki++;
          } else res += ch;
        }
        return res;
      };
      const vigenereDecode = (text, key) => {
        key = (key || '').toUpperCase().replace(/[^A-Z]/g,'');
        if (!key) throw new Error('√úres Vigen√®re kulcs');
        let res=''; let ki=0;
        for (let ch of text) {
          const isUpper = ch >= 'A' && ch <= 'Z';
          const isLower = ch >= 'a' && ch <= 'z';
          if (isUpper || isLower) {
            const base = isUpper ? 65 : 97;
            const shift = key.charCodeAt(ki % key.length) - 65;
            res += String.fromCharCode(base + (ch.charCodeAt(0) - base - shift + 26) % 26);
            ki++;
          } else res += ch;
        }
        return res;
      };

      // Caesar
      const caesarCipher = (str, shift) => str.replace(/[a-zA-Z]/g, ch => {
        const base = (ch <= 'Z') ? 65 : 97;
        return String.fromCharCode(base + (ch.charCodeAt(0) - base + shift + 26) % 26);
      });

      // ROT47 (FIXED formula)
      const rot47 = (s) => {
        let out = '';
        for (let i=0;i<s.length;i++) {
          const c = s.charCodeAt(i);
          if (c >= 33 && c <= 126) out += String.fromCharCode(33 + ((c - 33 + 47) % 94));
          else out += s[i];
        }
        return out;
      };

      /* ---------- encode / decode k√∂zponti f√ºggv√©nyek ---------- */
      const encode = (text, cipher, key) => {
        switch (cipher) {
          case 'rot13': return text.replace(/[a-z]/gi, ch => String.fromCharCode(ch.charCodeAt(0) + (ch.toLowerCase() <= 'm' ? 13 : -13)));
          case 'rot47': return rot47(text);
          case 'atbash': return text.replace(/[a-zA-Z]/g, ch => {
            const start = ch <= 'Z' ? 65 : 97;
            return String.fromCharCode(start + 25 - (ch.charCodeAt(0) - start));
          });
          case 'binary': return text.split('').map(c => c.charCodeAt(0).toString(2).padStart(8,'0')).join(' ');
          case 'base64': return btoa(unescape(encodeURIComponent(text)));
          case 'base85': return ascii85.encode(text);
          case 'base32': return encodeBase32(text);
          case 'base58': return encodeBase58(text);
          case 'hex': return text.split('').map(c => c.charCodeAt(0).toString(16).padStart(2,'0')).join(' ');
          case 'url': return encodeURIComponent(text);
          case 'caesar': return caesarCipher(text, parseInt(caesarShiftInput.value));
          case 'vigenere': return vigenereEncode(text, key);
          case 'morse': return text.toUpperCase().split('').map(c => morseCodeMap[c] || c).join(' ');
          case 'html-entities': return text.replace(/[\u00A0-\u9999<>&]/gim, i => '&#' + i.charCodeAt(0) + ';');
          case 'utf8': return unescape(encodeURIComponent(text));
          case 'leet': return text.toUpperCase().split('').map(c => leetSpeakMap[c] || c).join('');
          case 'emoji': return Array.from(text.toUpperCase()).map(c => emojiMap[c] || c).join('');
          default: return 'Ismeretlen k√≥dol√°s.';
        }
      };

      const decode = (text, cipher, key) => {
        try {
          switch (cipher) {
            case 'rot13': return text.replace(/[a-z]/gi, ch => String.fromCharCode(ch.charCodeAt(0) + (ch.toLowerCase() <= 'm' ? 13 : -13)));
            case 'rot47': return rot47(text);
            case 'atbash': return text.replace(/[a-zA-Z]/g, ch => {
              const start = ch <= 'Z' ? 65 : 97;
              return String.fromCharCode(start + 25 - (ch.charCodeAt(0) - start));
            });
            case 'binary': return text.split(' ').map(b => String.fromCharCode(parseInt(b,2))).join('');
            case 'base64': return decodeURIComponent(escape(atob(text)));
            case 'base85': return ascii85.decode(text);
            case 'base32': return decodeBase32(text);
            case 'base58': return decodeBase58(text);
            case 'hex': return text.split(' ').map(h => String.fromCharCode(parseInt(h,16))).join('');
            case 'url': return decodeURIComponent(text);
            case 'caesar': return caesarCipher(text, -parseInt(caesarShiftInput.value));
            case 'vigenere': return vigenereDecode(text, key);
            case 'morse': return text.split(' ').map(code => reverseMorseCodeMap[code] || code).join('');
            case 'html-entities': {
              const ta = document.createElement('textarea'); ta.innerHTML = text; return ta.value;
            }
            case 'utf8': return decodeURIComponent(escape(text));
            case 'leet': return text.split('').map(c => reverseLeetSpeakMap[c] || c).join('');
            case 'emoji': return Array.from(text).map(c => reverseEmojiMap[c] || c).join('');
            default: return 'Ismeretlen dek√≥dol√°s.';
          }
        } catch (e) {
          return '√ârv√©nytelen bevitel a kiv√°lasztott dek√≥dol√°shoz.';
        }
      };

      /* ---------- UI √©s esem√©nyek ---------- */
      function updateUI() {
        if (currentMode === 'encode') {
          messageInput.placeholder = "√çrd be az √ºzenetet a k√≥dol√°shoz...";
          switchModeBtn.textContent = "Dek√≥dol√°sra v√°lt√°s";
        } else {
          messageInput.placeholder = "√çrd be az √ºzenetet a dek√≥dol√°shoz...";
          switchModeBtn.textContent = "K√≥dol√°sra v√°lt√°s";
        }
      }

      function processMessage() {
        const msg = messageInput.value;
        const key = vigenereKeyInput.value.trim();
        const cipher = cipherSelect.value;
        let resultText = '';

        if (!msg) {
          resultText = 'K√©rlek, √≠rj be egy √ºzenetet!';
        } else if (cipher === 'vigenere' && key === '') {
          resultText = 'K√©rlek, add meg a Vigen√®re kulcsot!';
        } else {
          try {
            resultText = (currentMode === 'encode') ? encode(msg, cipher, key) : decode(msg, cipher, key);
          } catch (e) {
            resultText = 'Hiba: ' + (e.message || 'ismeretlen hiba');
          }
        }
        
        resultDiv.textContent = resultText;

        // √öj, robusztusabb logika a m√°sol√°s gomb √°llapot√°hoz
        const invalidResults = [
          'K√©rlek, √≠rj be egy √ºzenetet!', 
          'K√©rlek, add meg a Vigen√®re kulcsot!', 
          '√ârv√©nytelen bevitel a kiv√°lasztott dek√≥dol√°shoz.'
        ];
        
      function updateCounts() {
        const t = messageInput.value || '';
        charCountSpan.textContent = `${t.length} karakter`;
        const words = t.trim().split(/\s+/).filter(w=>w.length>0).length;
        wordCountSpan.textContent = `${words} sz√≥`;
      }

      // esem√©nyek
      switchModeBtn.addEventListener('click', () => {
        currentMode = (currentMode === 'encode') ? 'decode' : 'encode';
        messageInput.value = ''; vigenereKeyInput.value = ''; resultDiv.textContent = ''; updateUI(); updateCounts();
        copyBtn.disabled = true; // Kezdetben inakt√≠v
      });

      cipherSelect.addEventListener('change', () => {
        if (cipherSelect.value === 'vigenere') vigenereKeyGroup.classList.remove('hidden'); else vigenereKeyGroup.classList.add('hidden');
        if (cipherSelect.value === 'caesar') caesarShiftGroup.classList.remove('hidden'); else caesarShiftGroup.classList.add('hidden');
        processMessage();
      });

      caesarShiftInput.addEventListener('input', () => {
        caesarShiftValueSpan.textContent = caesarShiftInput.value;
        processMessage();
      });

     // Eredm√©ny friss√≠t√©sekor mutasd a gombot
function updateResult(text) {
  resultDiv.textContent = text;
  if (text.trim()) {
    copyBtn.classList.remove('hidden');
  } else {
    copyBtn.classList.add('hidden');
  }
}

// M√°sol√°s funkci√≥
copyBtn.addEventListener('click', () => {
  const text = resultDiv.textContent;
  navigator.clipboard.writeText(text).then(() => {
    copyBtn.textContent = "‚úîÔ∏è Kim√°solva!";
    setTimeout(() => {
      copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" ...>...</svg>`;
    }, 1500);
  }).catch(err => {
    console.error("M√°sol√°s sikertelen:", err);
  });
});

      messageInput.addEventListener('input', () => { updateCounts(); processMessage(); });
      vigenereKeyInput.addEventListener('input', processMessage);

      // inicializ√°l√°s
      updateUI();
      updateCounts();
    }); // DOMContentLoaded end
  </script>
</body>
</html>
